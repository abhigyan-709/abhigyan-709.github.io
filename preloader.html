<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Preloader</title>
    <style>
        body {
            margin: 0;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: rgb(0, 0, 0);
        }
        canvas {
            position: absolute;
        }
    </style>
</head>
<body>
    <canvas></canvas>
    <script>
        const turnRatio = 0.1;
        const bc = '0, 255, 233';
        const speed = 60;
        const lineWidth = 1;
        const backgroundColor = 'rgb(0,0,0)';
        
        const canvas = document.querySelector('canvas'); 
        const ctx = canvas.getContext('2d');
        const PI = Math.PI, rand = Math.random, cos = Math.cos, sin = Math.sin;
        const dirs = [0, PI/2, PI, PI/2*3, PI/4, PI/4*3, PI/4*5, PI/4*7];
        
        const onResize = () =>{
          canvas.width = window.innerWidth;
          canvas.height = window.innerHeight;
        }
        onResize();
        window.addEventListener('resize',onResize);
        const lines = [];
        
        function screenInit(){
          const amountParticles = Math.min(canvas.width*canvas.height*0.000032, 20);
          for(let i=0;i<amountParticles;i++){
            lines.push(new RunningLine(canvas, ctx));
          }
          requestAnimationFrame(animateAll);
        }
        function animateAll(){
          ctx.clearRect(0,0,canvas.width,canvas.height);
          ctx.fillStyle = backgroundColor;
          ctx.fillRect(0,0,canvas.width, canvas.height);
          lines.forEach(v=>v.draw(ctx));
          requestAnimationFrame(animateAll);
        }
        
        class RunningLine {
          prevTurnPoint = []
          constructor(canvas, ctx){
            this.init();
          }
          init(){
            this.prevTurnPoint = []
            const r = rand()
            if(r<0.25){
              this.x = rand()*canvas.width;
              this.dir = dirs[1];
              this.y = 0;
            }else if(r<0.5){
              this.x = rand()*canvas.width;
              this.dir = dirs[3];
              this.y = canvas.height;
            }else if(r<0.75){
              this.x = 0;
              this.dir = dirs[0];
              this.y = rand()*canvas.height;
            }else {
              this.x = canvas.width;
              this.dir = dirs[2];
              this.y = rand()*canvas.height;
            }
            this.prevTurnPoint.push({
              x:this.x,
              y:this.y,
            })
            this.width = lineWidth;
        
            this.v = speed;
        
            this.vx = this.v*cos(this.dir);
            this.vy = this.v*sin(this.dir);
            this.fadeout = false;
            this.opacity = (rand())**0.2
            this.color = `rgba(${bc}, ${this.opacity})`;
          }
          draw(ctx){
            if(this.fadeout){
              if(this.opacity<0.1){
                this.init();
              }else{
                this.opacity*=0.9;
                this.color = `rgba(${bc}, ${this.opacity})`;
              }
            }else{
              this.outOfScreen()
              this.x+=this.vx;
              this.y+=this.vy;
        
              if(rand()<turnRatio)this.turn()
            }
            ctx.strokeStyle = this.color;
            ctx.lineWidth = this.width;
            ctx.beginPath();
            ctx.moveTo(this.x, this.y);
            for(let i=this.prevTurnPoint.length-1;i>=0;i--){
              const p = this.prevTurnPoint[i];
              ctx.lineTo(p.x,p.y);
            }
            ctx.stroke();
            ctx.closePath();
          }
          turn(){
            const choice = dirs.filter(v=>{
              let a = Math.abs(this.dir-v);
              if(a>PI)a=2*PI-a;
              return a<=PI/2
            })
            this.dir = choice[rand()*choice.length^0]
            this.vx = this.v*cos(this.dir);
            this.vy = this.v*sin(this.dir);
            this.prevTurnPoint.push({
              x:this.x,
              y:this.y,
            })
          }
          outOfScreen(){
            if(this.x>=canvas.width&&this.vx>0||this.y>=canvas.height&&this.vy>0||this.x<=0&&this.vx<0||this.y<=0&&this.vy<0){
              this.fadeout = true;
            }
          }
        }
        window.onload = screenInit;

        function redirectToMainPage() {
            window.location.href = 'index.html';
        }

        setTimeout(redirectToMainPage, 3000);
    </script>
</body>
</html>
